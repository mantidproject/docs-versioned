<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>SmoothNeighbours v1</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SofQW v1" href="SofQW-v1.html" />
    <link rel="prev" title="SmoothMD v1" href="SmoothMD-v1.html" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59110517-1', 'auto');
  ga('send', 'pageview');

</script>


  </head><body>





  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www.mantidproject.org"><img src="../_static/Mantid_Logo_Transparent.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>6.5</b></span>
      </div>

      
        <div class="collapse navbar-collapse nav-collapse">
      
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="http://www.mantidproject.org">Home</a></li>
                <li><a href="http://download.mantidproject.org">Download</a></li>
                <li><a href="http://docs.mantidproject.org/nightly/">Documentation</a></li>
                <li><a href="http://www.mantidproject.org/Contact">Contact Us</a></li>
            
            
              
              
            
            
            
            
          </ul>
              
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
            </div>
    </div>
    <p>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">Documentation</a> &#187;</li>
        
            <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Algorithms</a> &#187;</li>
          
        
        
          
            <li class="nav-item nav-item-this"><a href="">SmoothNeighbours v1</a></li>
          
        
      </ul>
    </div> </p>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <p><span class="math notranslate nohighlight">\(\renewcommand\AA{\unicode{x212B}}\)</span></p>
<section id="smoothneighbours-v1">
<span id="algm-smoothneighbours"></span><span id="algm-smoothneighbours-v1"></span><h1>SmoothNeighbours v1<a class="headerlink" href="#smoothneighbours-v1" title="Permalink to this heading">¶</a></h1>
<figure class="align-right" id="id1">
<span id="index-0"></span><a class="screenshot reference internal image-reference" href="../_images/SmoothNeighbours-v1_dlg.png"><img alt="../_images/SmoothNeighbours-v1_dlg.png" class="screenshot" src="../_images/SmoothNeighbours-v1_dlg.png" style="width: 349px;" /></a>
<figcaption>
<p><span class="caption-text"><strong>SmoothNeighbours</strong> dialog.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<nav class="contents local" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#summary" id="id2">Summary</a></p>
<ul>
<li><p><a class="reference internal" href="#see-also" id="id3">See Also</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#properties" id="id4">Properties</a></p></li>
<li><p><a class="reference internal" href="#description" id="id5">Description</a></p>
<ul>
<li><p><a class="reference internal" href="#processing-either-generically-or-assuming-rectangular-detectors" id="id6">Processing Either Generically or Assuming Rectangular Detectors</a></p></li>
<li><p><a class="reference internal" href="#for-all-instruments" id="id7">For All Instruments</a></p></li>
<li><p><a class="reference internal" href="#for-instruments-with-rectangular-detectors" id="id8">For Instruments With Rectangular Detectors</a></p></li>
<li><p><a class="reference internal" href="#weightedsum-parameter" id="id9">WeightedSum parameter</a></p></li>
<li><p><a class="reference internal" href="#flat-weighting" id="id10">Flat Weighting</a></p></li>
<li><p><a class="reference internal" href="#linear-weighting" id="id11">Linear Weighting</a></p></li>
<li><p><a class="reference internal" href="#parabolic-weighting" id="id12">Parabolic Weighting</a></p></li>
<li><p><a class="reference internal" href="#gaussian-weighting" id="id13">Gaussian Weighting</a></p></li>
<li><p><a class="reference internal" href="#for-eventworkspaces" id="id14">For EventWorkspaces</a></p></li>
<li><p><a class="reference internal" href="#for-workspace2d-s" id="id15">For Workspace2D’s</a></p></li>
<li><p><a class="reference internal" href="#neighbour-searching" id="id16">Neighbour Searching</a></p></li>
<li><p><a class="reference internal" href="#property-values-of-examples" id="id17">Property Values of Examples</a></p></li>
<li><p><a class="reference internal" href="#how-it-works" id="id18">How it Works</a></p></li>
<li><p><a class="reference internal" href="#ignore-masks" id="id19">Ignore Masks</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#usage" id="id20">Usage</a></p></li>
<li><p><a class="reference internal" href="#source" id="id21">Source</a></p></li>
</ul>
</nav>
<section id="summary">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Summary</a><a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>Perform a moving-average smoothing by summing spectra of nearest neighbours over the face of detectors.</p>
<section id="see-also">
<h3><a class="toc-backref" href="#id3" role="doc-backlink">See Also</a><a class="headerlink" href="#see-also" title="Permalink to this heading">¶</a></h3>
<p><a class="reference internal" href="SmoothData-v1.html#algm-smoothdata"><span class="std std-ref">SmoothData</span></a></p>
</section>
</section>
<section id="properties">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Properties</a><a class="headerlink" href="#properties" title="Permalink to this heading">¶</a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Direction</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>InputWorkspace</p></td>
<td><p>Input</p></td>
<td><p><a class="reference internal" href="../concepts/MatrixWorkspace.html#matrixworkspace"><span class="std std-ref">MatrixWorkspace</span></a></p></td>
<td><p><em>Mandatory</em></p></td>
<td><p>The workspace containing the spectra to be averaged.</p></td>
</tr>
<tr class="row-odd"><td><p>OutputWorkspace</p></td>
<td><p>Output</p></td>
<td><p><a class="reference internal" href="../concepts/MatrixWorkspace.html#matrixworkspace"><span class="std std-ref">MatrixWorkspace</span></a></p></td>
<td><p><em>Mandatory</em></p></td>
<td><p>The name of the workspace to be created as the output of the algorithm.</p></td>
</tr>
<tr class="row-even"><td><p>WeightedSum</p></td>
<td><p>Input</p></td>
<td><p>string</p></td>
<td><p>Flat</p></td>
<td><p>What sort of Weighting scheme to use?   Flat: Effectively no-weighting, all weights are 1.   Linear: Linear weighting 1 - r/R from origin.   Parabolic : Weighting as cutoff - x + cutoff - y + 1.  Gaussian : Uses the absolute distance x^2 + y^2 … normalised by the cutoff^2. Allowed values: [‘Flat’, ‘Linear’, ‘Parabolic’, ‘Gaussian’]</p></td>
</tr>
<tr class="row-odd"><td><p>Sigma</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>0.5</p></td>
<td><p>Sigma value for gaussian weighting schemes. Defaults to 0.5.</p></td>
</tr>
<tr class="row-even"><td><p>IgnoreMaskedDetectors</p></td>
<td><p>Input</p></td>
<td><p>boolean</p></td>
<td><p>True</p></td>
<td><p>If true, do not consider masked detectors in the NN search.</p></td>
</tr>
<tr class="row-odd"><td><p>PreserveEvents</p></td>
<td><p>Input</p></td>
<td><p>boolean</p></td>
<td><p>True</p></td>
<td><p>If the InputWorkspace is an EventWorkspace, this will preserve the full event list (warning: this will use much more memory!).</p></td>
</tr>
<tr class="row-even"><td><p>AdjX</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>1</p></td>
<td><p>The number of X (horizontal) adjacent pixels to average together. Only for instruments with RectangularDetectors.</p></td>
</tr>
<tr class="row-odd"><td><p>AdjY</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>1</p></td>
<td><p>The number of Y (vertical) adjacent pixels to average together. Only for instruments with RectangularDetectors.</p></td>
</tr>
<tr class="row-even"><td><p>SumPixelsX</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>1</p></td>
<td><p>The total number of X (horizontal) adjacent pixels to sum together. Only for instruments with RectangularDetectors.  AdjX will be ignored if SumPixelsX &gt; 1.</p></td>
</tr>
<tr class="row-odd"><td><p>SumPixelsY</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>1</p></td>
<td><p>The total number of Y (vertical) adjacent pixels to sum together. Only for instruments with RectangularDetectors. AdjY will be ignored if SumPixelsY &gt; 1</p></td>
</tr>
<tr class="row-even"><td><p>ZeroEdgePixels</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>0</p></td>
<td><p>The number of pixels to zero at edges. Only for instruments with RectangularDetectors.</p></td>
</tr>
<tr class="row-odd"><td><p>RadiusUnits</p></td>
<td><p>Input</p></td>
<td><p>string</p></td>
<td><p>Meters</p></td>
<td><p>Units used to specify the radius.   Meters : Radius is in meters.   NumberOfPixels : Radius is in terms of the number of pixels. Allowed values: [‘Meters’, ‘NumberOfPixels’]</p></td>
</tr>
<tr class="row-even"><td><p>Radius</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>0</p></td>
<td><p>The radius cut-off around a pixel to look for nearest neighbours to average.  This radius cut-off is applied to a set of nearest neighbours whose number is defined in the NumberOfNeighbours property. See below for more details.  If 0, will use the AdjX and AdjY parameters for rectangular detectors instead.</p></td>
</tr>
<tr class="row-odd"><td><p>NumberOfNeighbours</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>8</p></td>
<td><p>Number of nearest neighbouring pixels. The default is 8.</p></td>
</tr>
<tr class="row-even"><td><p>SumNumberOfNeighbours</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>1</p></td>
<td><p>Sum nearest neighbouring pixels with same parent. Number of pixels will be reduced. The default is false.</p></td>
</tr>
<tr class="row-odd"><td><p>ExpandSumAllPixels</p></td>
<td><p>Input</p></td>
<td><p>boolean</p></td>
<td><p>False</p></td>
<td><p>OuputWorkspace will have same number of pixels as InputWorkspace using SumPixelsX and SumPixelsY.  Individual pixels will have averages.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="description">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Description</a><a class="headerlink" href="#description" title="Permalink to this heading">¶</a></h2>
<p>This algorithm performs a moving-average smoothing of data by summing
spectra of nearest neighbours over the face of detectors. The output
workspace has the same number of spectra as the input workspace. This
works on both <a class="reference internal" href="../concepts/EventWorkspace.html#eventworkspace"><span class="std std-ref">EventWorkspaces</span></a> and
<a class="reference internal" href="../concepts/Workspace2D.html#workspace2d"><span class="std std-ref">Workspace2D</span></a>’s. It has two main modes of operation.</p>
<section id="processing-either-generically-or-assuming-rectangular-detectors">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Processing Either Generically or Assuming Rectangular Detectors</a><a class="headerlink" href="#processing-either-generically-or-assuming-rectangular-detectors" title="Permalink to this heading">¶</a></h3>
<p>You may either specify properties for the Rectangular Detector Group, or
the Non-uniform Detector Group, but not both. If you provide inputs for
the Rectangular Detector group, then the algorithm execution will assume
that this is your desired processing route.</p>
</section>
<section id="for-all-instruments">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">For All Instruments</a><a class="headerlink" href="#for-all-instruments" title="Permalink to this heading">¶</a></h3>
<p>Going through the input workspace pixel-by-pixel, Mantid finds the
nearest-neighbours with the given Radius of each pixel. The spectra are
then summed together, and normalizing to unity (see the weighting
section below).</p>
</section>
<section id="for-instruments-with-rectangular-detectors">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">For Instruments With Rectangular Detectors</a><a class="headerlink" href="#for-instruments-with-rectangular-detectors" title="Permalink to this heading">¶</a></h3>
<p>The algorithm looks through the <a class="reference internal" href="../concepts/Instrument.html#instrument"><span class="std std-ref">Instrument</span></a> to find all
the <a class="reference internal" href="../concepts/RectangularDetector.html#rectangulardetector"><span class="std std-ref">RectangularDetectors</span></a> defined. For each
pixel in each detector, the AdjX*AdjY neighboring spectra are summed
together and saved in the output workspace.</p>
</section>
<section id="weightedsum-parameter">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">WeightedSum parameter</a><a class="headerlink" href="#weightedsum-parameter" title="Permalink to this heading">¶</a></h3>
<p>A weighting strategy can be applied to control how the weights are
calculated. This defaults to a flat weighting strategy. Weights are
summed and scaled so that they add up to 1.</p>
</section>
<section id="flat-weighting">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Flat Weighting</a><a class="headerlink" href="#flat-weighting" title="Permalink to this heading">¶</a></h3>
<p>All weights are 1. This is completely position in-senitive.</p>
</section>
<section id="linear-weighting">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Linear Weighting</a><a class="headerlink" href="#linear-weighting" title="Permalink to this heading">¶</a></h3>
<p>Weights are calculated according to <span class="math notranslate nohighlight">\(w = 1 - r/R\)</span>, where <span class="math notranslate nohighlight">\(w\)</span> is the
weighting factor, <span class="math notranslate nohighlight">\(r\)</span> is the distance from the detector and <span class="math notranslate nohighlight">\(R\)</span> is the
cut-off radius.</p>
</section>
<section id="parabolic-weighting">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Parabolic Weighting</a><a class="headerlink" href="#parabolic-weighting" title="Permalink to this heading">¶</a></h3>
<p>For rectangular detectors it may be used as follows: The radius must be
zero and a AdjX and AdjY parameter must be provided.
<span class="math notranslate nohighlight">\(w = AdjX - abs(x) + AdjY - abs(y) + 1\)</span></p>
<p>For non-rectangular detectors, the cut-off radius is used in the
calculation. <span class="math notranslate nohighlight">\(w = R - abs(x) + R - abs(y) + 1\)</span></p>
</section>
<section id="gaussian-weighting">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Gaussian Weighting</a><a class="headerlink" href="#gaussian-weighting" title="Permalink to this heading">¶</a></h3>
<p>This weighting is calculated from the Gaussian distribution</p>
<p><span class="math notranslate nohighlight">\(w = e^{-r^2/(2\sigma^2)}\)</span></p>
<p>where <span class="math notranslate nohighlight">\(r^2 = x^2 + y^2 + z^2\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span> is the number of
standard deviations controlling the width of the distribution curve</p>
<p>Important notes about this algorithm are that:</p>
<ul class="simple">
<li><p>Distances are normalised by the radius cut-off to make them
dimensionless and scaled to 1 at the boundaries.</p></li>
</ul>
</section>
<section id="for-eventworkspaces">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">For EventWorkspaces</a><a class="headerlink" href="#for-eventworkspaces" title="Permalink to this heading">¶</a></h3>
<p>Both methods of smoothing will <strong>significantly</strong> increase the memory
usage of the workspace. For example, if AdjX=AdjY=1, the algorithm will
sum 9 nearest neighbours in most cases. This increases the memory used
by a factor of 9.</p>
</section>
<section id="for-workspace2d-s">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">For Workspace2D’s</a><a class="headerlink" href="#for-workspace2d-s" title="Permalink to this heading">¶</a></h3>
<p>You can use PreserveEvents = false to avoid the memory issues with an
EventWorkspace input. Please note that the algorithm <strong>does not check</strong>
that the bin X boundaries match.</p>
</section>
<section id="neighbour-searching">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Neighbour Searching</a><a class="headerlink" href="#neighbour-searching" title="Permalink to this heading">¶</a></h3>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="../_images/NNSearchByRadius.jpg"><img alt="Fig1" src="../_images/NNSearchByRadius.jpg" style="width: 100%;" /></a></p></td>
<td><p><a class="reference internal" href="../_images/NNSearchIrregularGrid.jpg"><img alt="Fig2" src="../_images/NNSearchIrregularGrid.jpg" style="width: 100%;" /></a></p></td>
<td><p><a class="reference internal" href="../_images/NNSearchLimitByRadius.jpg"><img alt="Fig3" src="../_images/NNSearchLimitByRadius.jpg" style="width: 100%;" /></a></p></td>
<td><p><a class="reference internal" href="../_images/NNSearchLimitByNNs.jpg"><img alt="Fig4" src="../_images/NNSearchLimitByNNs.jpg" style="width: 100%;" /></a></p></td>
<td><p><a class="reference internal" href="../_images/NNSearchXY.jpg"><img alt="Fig5" src="../_images/NNSearchXY.jpg" style="width: 100%;" /></a></p></td>
</tr>
<tr class="row-even"><td><p><em>Fig. 1</em></p></td>
<td><p><em>Fig. 2</em></p></td>
<td><p><em>Fig. 3</em></p></td>
<td><p><em>Fig. 4</em></p></td>
<td><p><em>Fig. 5</em></p></td>
</tr>
</tbody>
</table>
</section>
<section id="property-values-of-examples">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Property Values of Examples</a><a class="headerlink" href="#property-values-of-examples" title="Permalink to this heading">¶</a></h3>
<ul>
<li><p><strong>Fig. 1:</strong></p>
<p>Requesting NumberOfNeighbours=36, Radius=3. Algorithm looks for
36 nearest neighbours with a cut-off of 3 detector widths.</p>
</li>
<li><p><strong>Fig. 2:</strong></p>
<p>Requesting NumberOfNeighbours=46, Radius=2. Algorithm looks
for 46 nearest neighbours with a cut-off of 2 detector widths.</p>
</li>
<li><p><strong>Fig. 3:</strong></p>
<p>Requesting NumberOfNeighbours=56, Radius=3. Algorithm looks
for 56 nearest neighbours with a cut-off of 3 detector widths.</p>
</li>
<li><p><strong>Fig. 4:</strong></p>
<p>Requesting NumberOfNeighbours=8, Radius=3. Algorithm looks
for 8 nearest neighbours with a cut-off of 3 detector widths.</p>
</li>
<li><p><strong>Fig. 5:</strong></p>
<p>Requesting AdjX=4, AdjY=2, Radius=0. Algorithm fetches
neighbours in the specified pattern.</p>
</li>
</ul>
</section>
<section id="how-it-works">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">How it Works</a><a class="headerlink" href="#how-it-works" title="Permalink to this heading">¶</a></h3>
<p>The algorithm will fetch neighbours using the intesection of those inside
the radius cut-off and those less than the NumberOfNeighbours specified.
<em>Fig. 1</em> illustrates this process. Searching is relative to the central
detector, those constrained by both specified number of neighbours have
been highlighted. In this case the radius cut-off and the number of
neighbours constrain the same number of detectors.</p>
<p>Searching via the number of neighbours will not necessarily return the
neighbours in a grid with the same number of detectors in each axis.
<em>Fig. 2</em> shows how neighbours might be returned if distances are
non-uniform. If RectangularDetectors are available, you may force the
searching to occur in rectangular manner (described below).</p>
<p>The SmoothingNeighbours algorithm will only take those neighbours which
are in the intersection between those constrained by the cut-off and
those constrained by the specified number of neighbours. If the radius
cut-off is the limiting factor, then those neighbours outside will not
be considered. This is illustrated in <em>Fig. 3</em> where the blue detectors
will not be considered, but will not with this radius cut-off, while the
green ones will. Likewise, in <em>Fig. 4</em> the effect of reducing the
NumberOfNeighbours property can be seen.</p>
<p>If the radius is set to 0, the instrument is treated as though it has
rectangular detectors. AdjX and AdjY can then be used to control the
number of neighbours independently in x and y using the AdjX and AdjY
properties. <em>Fig. 5</em> Shows the effect of this type of searching.</p>
</section>
<section id="ignore-masks">
<h3><a class="toc-backref" href="#id19" role="doc-backlink">Ignore Masks</a><a class="headerlink" href="#ignore-masks" title="Permalink to this heading">¶</a></h3>
<p>The algorithm will ignore masked detectors if this flag is set.</p>
</section>
</section>
<section id="usage">
<h2><a class="toc-backref" href="#id20" role="doc-backlink">Usage</a><a class="headerlink" href="#usage" title="Permalink to this heading">¶</a></h2>
<p><strong>Example - Smooth using radius:</strong></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a workspace with a single rectangular bank of size 3x3. One bin only.</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">CreateSampleWorkspace</span><span class="p">(</span><span class="n">Function</span><span class="o">=</span><span class="s2">&quot;Flat background&quot;</span><span class="p">,</span>
                           <span class="n">NumBanks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">BankPixelWidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                           <span class="n">XMin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">XMax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">BinWidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Initial values</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span>
          <span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span>
          <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">):</span>
  <span class="n">ws</span><span class="o">.</span><span class="n">dataY</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># Run the algorithm</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">SmoothNeighbours</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">Radius</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                          <span class="n">RadiusUnits</span> <span class="o">=</span> <span class="s1">&#39;NumberOfPixels&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of histograms: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Smoothed values:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">extractY</span><span class="p">())</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Number of histograms: 9
Smoothed values:
[[ 2.        ]
 [ 2.16666667]
 [ 2.        ]
 [ 2.        ]
 [ 2.22222222]
 [ 2.33333333]
 [ 2.5       ]
 [ 2.5       ]
 [ 2.5       ]]
</pre></div>
</div>
<p><strong>Example -  Smooth using AdjX and AdjY:</strong></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a workspace with a single rectangular bank of size 3x3. One bin only.</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">CreateSampleWorkspace</span><span class="p">(</span><span class="n">Function</span><span class="o">=</span><span class="s2">&quot;Flat background&quot;</span><span class="p">,</span>
                           <span class="n">NumBanks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">BankPixelWidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                           <span class="n">XMin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">XMax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">BinWidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Initial values</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span>
          <span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span>
          <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">):</span>
  <span class="n">ws</span><span class="o">.</span><span class="n">dataY</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># Run the algorithm</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">SmoothNeighbours</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">AdjX</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">AdjY</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of histograms: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Smoothed values:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">extractY</span><span class="p">())</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Number of histograms: 9
Smoothed values:
[[ 2.16666667]
 [ 2.16666667]
 [ 2.16666667]
 [ 2.22222222]
 [ 2.22222222]
 [ 2.22222222]
 [ 2.5       ]
 [ 2.5       ]
 [ 2.5       ]]
</pre></div>
</div>
<p><strong>Example -  Smooth and sum using SumPixelsX and SumPixelsY:</strong></p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a workspace with a single rectangular bank of size 3x3. One bin only.</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">CreateSampleWorkspace</span><span class="p">(</span><span class="n">Function</span><span class="o">=</span><span class="s2">&quot;Flat background&quot;</span><span class="p">,</span>
                           <span class="n">NumBanks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">BankPixelWidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                           <span class="n">XMin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">XMax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">BinWidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Initial values</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span>
          <span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span>
          <span class="mf">1.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">):</span>
  <span class="n">ws</span><span class="o">.</span><span class="n">dataY</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># Run the algorithm</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">SmoothNeighbours</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">SumPixelsX</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">SumPixelsY</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of histograms: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Smoothed values:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">extractY</span><span class="p">())</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Number of histograms: 3
Smoothed values:
[[ 6.]
 [ 6.]
 [ 8.]]
</pre></div>
</div>
<p><strong>Categories</strong>: <a class="reference external" href="categories/AlgorithmIndex.html">AlgorithmIndex</a> | <a class="reference external" href="categories/Transforms/Smoothing.html">Transforms\Smoothing</a></p>
</section>
<section id="source">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Source</a><a class="headerlink" href="#source" title="Permalink to this heading">¶</a></h2>
<p>C++ header: <a class="reference external" href="https://github.com/mantidproject/mantid/blob/d01b3431ef42c8e811acf3df5a3cc0503656d488/Framework/Algorithms/inc/MantidAlgorithms/SmoothNeighbours.h">SmoothNeighbours.h</a></p>
<p>C++ source: <a class="reference external" href="https://github.com/mantidproject/mantid/blob/d01b3431ef42c8e811acf3df5a3cc0503656d488/Framework/Algorithms/src/SmoothNeighbours.cpp">SmoothNeighbours.cpp</a></p>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
      <ul class="nav navbar-nav" style=" float: right;">
      
      
          
            
  <li>
    <a href="SmoothMD-v1.html" title="Previous Chapter: SmoothMD v1"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; SmoothMD v1</span>
    </a>
  </li>
  <li>
    <a href="SofQW-v1.html" title="Next Chapter: SofQW v1"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">SofQW v1 &raquo;</span>
    </a>
  </li>
          
       
          <li><a href="#">Back to top</a></li>
       </ul>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>