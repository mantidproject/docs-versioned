<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>DiscusMultipleScatteringCorrection v1</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Divide v1" href="Divide-v1.html" />
    <link rel="prev" title="DirectILLTubeBackground v1" href="DirectILLTubeBackground-v1.html" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59110517-1', 'auto');
  ga('send', 'pageview');

</script>


  </head><body>





  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www.mantidproject.org"><img src="../_static/Mantid_Logo_Transparent.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>6.5</b></span>
      </div>

      
        <div class="collapse navbar-collapse nav-collapse">
      
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="https://www.mantidproject.org">Home</a></li>
                <li><a href="https://download.mantidproject.org">Download</a></li>
                <li><a href="https://docs.mantidproject.org">Documentation</a></li>
                <li><a href="https://www.mantidproject.org/contact">Contact Us</a></li>
            
            
              
              
            
            
            
            
          </ul>
              
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
            </div>
    </div>
    <p>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">Documentation</a> &#187;</li>
        
            <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Algorithms</a> &#187;</li>
          
        
        
          
            <li class="nav-item nav-item-this"><a href="">DiscusMultipleScatteringCorrection v1</a></li>
          
        
      </ul>
    </div> </p>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <p><span class="math notranslate nohighlight">\(\renewcommand\AA{\unicode{x212B}}\)</span></p>
<section id="discusmultiplescatteringcorrection-v1">
<span id="algm-discusmultiplescatteringcorrection"></span><span id="algm-discusmultiplescatteringcorrection-v1"></span><h1>DiscusMultipleScatteringCorrection v1<a class="headerlink" href="#discusmultiplescatteringcorrection-v1" title="Permalink to this heading">¶</a></h1>
<figure class="align-right" id="id7">
<span id="index-0"></span><a class="screenshot reference internal image-reference" href="../_images/DiscusMultipleScatteringCorrection-v1_dlg.png"><img alt="../_images/DiscusMultipleScatteringCorrection-v1_dlg.png" class="screenshot" src="../_images/DiscusMultipleScatteringCorrection-v1_dlg.png" style="width: 349px;" /></a>
<figcaption>
<p><span class="caption-text"><strong>DiscusMultipleScatteringCorrection</strong> dialog.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<nav class="contents local" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#summary" id="id8">Summary</a></p>
<ul>
<li><p><a class="reference internal" href="#see-also" id="id9">See Also</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#properties" id="id10">Properties</a></p></li>
<li><p><a class="reference internal" href="#description" id="id11">Description</a></p>
<ul>
<li><p><a class="reference internal" href="#theory" id="id12">Theory</a></p>
<ul>
<li><p><a class="reference internal" href="#importance-sampling" id="id13">Importance Sampling</a></p></li>
<li><p><a class="reference internal" href="#support-for-sample-environment" id="id14">Support for sample environment</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#outputs" id="id15">Outputs</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#usage" id="id16">Usage</a></p></li>
<li><p><a class="reference internal" href="#references" id="id17">References</a></p></li>
<li><p><a class="reference internal" href="#source" id="id18">Source</a></p></li>
</ul>
</nav>
<section id="summary">
<h2><a class="toc-backref" href="#id8" role="doc-backlink">Summary</a><a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>Calculates a multiple scattering correction using a Monte Carlo method</p>
<section id="see-also">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">See Also</a><a class="headerlink" href="#see-also" title="Permalink to this heading">¶</a></h3>
<p><a class="reference internal" href="MayersSampleCorrection-v1.html#algm-mayerssamplecorrection"><span class="std std-ref">MayersSampleCorrection</span></a>, <a class="reference internal" href="CarpenterSampleCorrection-v1.html#algm-carpentersamplecorrection"><span class="std std-ref">CarpenterSampleCorrection</span></a>, <a class="reference internal" href="VesuvioCalculateMS-v1.html#algm-vesuviocalculatems"><span class="std std-ref">VesuvioCalculateMS</span></a></p>
<p>This algorithm is also known as: <strong>Muscat</strong></p>
</section>
</section>
<section id="properties">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Properties</a><a class="headerlink" href="#properties" title="Permalink to this heading">¶</a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Direction</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>InputWorkspace</p></td>
<td><p>Input</p></td>
<td><p><a class="reference internal" href="../concepts/MatrixWorkspace.html#matrixworkspace"><span class="std std-ref">MatrixWorkspace</span></a></p></td>
<td><p><em>Mandatory</em></p></td>
<td><p>The name of the input workspace.  The input workspace must have X units of Momentum (k) for elastic calculations and units of energy transfer (DeltaE) for inelastic calculations. This is used to supply the sample details, the detector positions and the x axis range to calculate corrections for</p></td>
</tr>
<tr class="row-odd"><td><p>StructureFactorWorkspace</p></td>
<td><p>Input</p></td>
<td><p><a class="reference internal" href="../concepts/Workspace.html#workspace"><span class="std std-ref">Workspace</span></a></p></td>
<td><p><em>Mandatory</em></p></td>
<td><p>The name of the workspace containing S’(q) or S’(q, w).  For elastic calculations, the input workspace must contain a single spectrum and have X units of momentum transfer. A workspace group containing one workspace per component can also be supplied if a calculation is being run on a workspace with a sample environment specified</p></td>
</tr>
<tr class="row-even"><td><p>OutputWorkspace</p></td>
<td><p>Output</p></td>
<td><p>WorkspaceGroup</p></td>
<td><p><em>Mandatory</em></p></td>
<td><p>Name for the WorkspaceGroup that will be created. Each workspace in the group contains a calculated weight for a particular number of scattering events. The number of scattering events varies from 1 up to the number supplied in the NumberOfScatterings parameter. The group will also include an additional workspace for a calculation with a single scattering event where the absorption post scattering has been set to zero</p></td>
</tr>
<tr class="row-odd"><td><p>ScatteringCrossSection</p></td>
<td><p>Input</p></td>
<td><p><a class="reference internal" href="../concepts/MatrixWorkspace.html#matrixworkspace"><span class="std std-ref">MatrixWorkspace</span></a></p></td>
<td></td>
<td><p>A workspace containing the scattering cross section as a function of k, <span class="math notranslate nohighlight">\(\sigma_s(k)\)</span>. Note - this parameter would normally be left empty which results in the tabulated cross section data being used instead which implies no wavelength dependence</p></td>
</tr>
<tr class="row-even"><td><p>NumberOfSimulationPoints</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p><em>Optional</em></p></td>
<td><p>The number of points on the input workspace x axis for which a simulation is attempted</p></td>
</tr>
<tr class="row-odd"><td><p>NeutronPathsSingle</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>1000</p></td>
<td><p>The number of “neutron” paths to generate for single scattering</p></td>
</tr>
<tr class="row-even"><td><p>NeutronPathsMultiple</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>1000</p></td>
<td><p>The number of “neutron” paths to generate for multiple scattering</p></td>
</tr>
<tr class="row-odd"><td><p>SeedValue</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>123456789</p></td>
<td><p>Seed the random number generator with this value</p></td>
</tr>
<tr class="row-even"><td><p>NumberScatterings</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>2</p></td>
<td><p>Number of scatterings</p></td>
</tr>
<tr class="row-odd"><td><p>Interpolation</p></td>
<td><p>Input</p></td>
<td><p>string</p></td>
<td><p>Linear</p></td>
<td><p>Method of interpolation used to compute unsimulated values. Allowed values: [‘Linear’, ‘CSpline’]</p></td>
</tr>
<tr class="row-even"><td><p>SparseInstrument</p></td>
<td><p>Input</p></td>
<td><p>boolean</p></td>
<td><p>False</p></td>
<td><p>Enable simulation on special instrument with a sparse grid of detectors interpolating the results to the real instrument.</p></td>
</tr>
<tr class="row-odd"><td><p>NumberOfDetectorRows</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>5</p></td>
<td><p>Number of detector rows in the detector grid of the sparse instrument.</p></td>
</tr>
<tr class="row-even"><td><p>NumberOfDetectorColumns</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>10</p></td>
<td><p>Number of detector columns in the detector grid of the sparse instrument.</p></td>
</tr>
<tr class="row-odd"><td><p>ImportanceSampling</p></td>
<td><p>Input</p></td>
<td><p>boolean</p></td>
<td><p>False</p></td>
<td><p>Enable importance sampling on the Q value chosen on multiple scatters based on Q.S(Q)</p></td>
</tr>
<tr class="row-even"><td><p>MaxScatterPtAttempts</p></td>
<td><p>Input</p></td>
<td><p>number</p></td>
<td><p>5000</p></td>
<td><p>Maximum number of tries made to generate a scattering point within the sample. Objects with holes in them, e.g. a thin annulus can cause problems if this number is too low. If a scattering point cannot be generated by increasing this value then there is most likely a problem with the sample geometry.</p></td>
</tr>
<tr class="row-odd"><td><p>SimulateEnergiesIndependently</p></td>
<td><p>Input</p></td>
<td><p>boolean</p></td>
<td><p>False</p></td>
<td><p>For inelastic calculation, whether the results for adjacent energy transfer bins are simulated separately. Currently applies to Direct geometry only</p></td>
</tr>
<tr class="row-even"><td><p>NormalizeStructureFactors</p></td>
<td><p>Input</p></td>
<td><p>boolean</p></td>
<td><p>False</p></td>
<td><p>Enable normalization of supplied structure factor(s). May be required when running a calculation involving more than one material where the normalization of the default S(Q)=1 structure factor doesn’t match the normalization of a supplied non-isotropic structure factor</p></td>
</tr>
</tbody>
</table>
</section>
<section id="description">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Description</a><a class="headerlink" href="#description" title="Permalink to this heading">¶</a></h2>
<p>This algorithm calculates a Multiple Scattering correction using a Monte Carlo integration method.
The method uses a structure function for the sample to determine the probability of a particular momentum transfer (q) and energy transfer (<span class="math notranslate nohighlight">\(\omega\)</span>) value for each scattering event and it doesn’t therefore rely on an assumption that the scattering is isotropic.</p>
<p>The structure function that the algorithm takes as input is a linear combination of the coherent and incoherent structure factors:</p>
<p><span class="math notranslate nohighlight">\(S'(Q, \omega) = \frac{1}{\sigma_b}(\sigma_{coh} S(Q, \omega) + \sigma_{inc} S_s(Q, \omega))\)</span></p>
<p>If the sample is a perfectly coherent scatterer then <span class="math notranslate nohighlight">\(S'(Q, \omega) = S(Q, \omega)\)</span></p>
<p>The algorithm is based on code which was originally written in Fortran as part of the Discus program <a class="footnote-reference brackets" href="#joh" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. The code was subsequently resurrected and improved by Spencer Howells under the Muscat name and was included in the QENS MODES package <a class="footnote-reference brackets" href="#how" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, <a class="footnote-reference brackets" href="#how2" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
These original programs calculated multiple scattering corrections for inelastic instruments but an elastic diffraction version of the code was also created and results from that program are included in this paper by Mancinelli <a class="footnote-reference brackets" href="#man" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.</p>
<section id="theory">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Theory</a><a class="headerlink" href="#theory" title="Permalink to this heading">¶</a></h3>
<p>The theory is outlined here for an inelastic calculation. The calculation performed for an elastic instrument is a special case of this with <span class="math notranslate nohighlight">\(\omega=0\)</span>.</p>
<p>The algorithm calculates a set of dimensionless weights <span class="math notranslate nohighlight">\(J_n\)</span> describing the probability of detection at an angle <span class="math notranslate nohighlight">\(\theta\)</span> after n scattering events given a total incident flux <span class="math notranslate nohighlight">\(I_0\)</span> and a transmitted flux of T:</p>
<p><span class="math notranslate nohighlight">\(T_n(\theta,k_{in}, \omega) = J_n(\theta,k_{in}, \omega) I_0(k_{in})\)</span></p>
<p>The quantity <span class="math notranslate nohighlight">\(J_n\)</span> is calculated by performing the following integration:</p>
<div class="math notranslate nohighlight">
\[\begin{split}J_n &amp;= (\frac{\mu_s}{4 \pi})^n \frac{1}{A} \int dS \int_{0}^{l_1^{max}} dl_1 e^{-\mu_T l_1} \prod\limits_{i=1}^{n-1} [\int_{0}^{l_{i+1}^{max}} dl_{i+1} \int_{0}^{\pi} \sin\theta_i d\theta_i \int_{0}^{2 \pi} d\phi_i \int_{\omega^{min}}^{\omega_i^{max}} d\omega_i (e^{-\mu_T l_{i+1}}) \frac{k_{i+1}}{k_i} S(Q_i, \omega_i)] e^{-\mu_T l_{out}} S(Q_n, \omega_n) \\
    &amp;=(\frac{\mu_s}{4 \pi})^n \frac{1}{A} \int dS \int_{0}^{l_1^{max}} dl_1 e^{-\mu_T l_1} \prod\limits_{i=1}^{n-1} [\int_{0}^{l_{i+1}^{max}} dl_{i+1} \int_{0}^{2 \pi} d\phi_i \iint \limits_{D(k_i)} dQ_i d\omega_i (e^{-\mu_T l_{i+1}}) \frac{Q_i}{k_i^2} S(Q_i, \omega_i)] e^{-\mu_T l_{out}} S(Q_n, \omega_n)\end{split}\]</div>
<p>The variables <span class="math notranslate nohighlight">\(l_i^{max}\)</span> represent the maximum path length before the next scatter given a particular phi and theta value (Q). Each <span class="math notranslate nohighlight">\(l_i\)</span> is actually a function of all of the earlier values for the <span class="math notranslate nohighlight">\(l_i\)</span>, <span class="math notranslate nohighlight">\(\phi\)</span>, <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(\omega\)</span> variables ie <span class="math notranslate nohighlight">\(l_i = l_i(l_1, l_2, ..., l_{i-1}, \phi_1, \phi_2, ..., \phi_i, Q_1, Q_2, ..., Q_i, \omega_1, \omega_2, ..., \omega_i)\)</span>.
The integration over the variables <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(\omega\)</span> is done over the kinematically accessible region <span class="math notranslate nohighlight">\(D(k_i)\)</span>. The integral is done over <span class="math notranslate nohighlight">\(\omega\)</span> first and the range is defined by the minimum value on the <span class="math notranslate nohighlight">\(\omega\)</span> axis in the <span class="math notranslate nohighlight">\(S(Q, \omega)\)</span> profile and a maximum which is equal to the total energy loss of the pre-scatter neutron prior to the ith scatter.
The limits on the q integration are then calculated as follows (and are also a function of i). These formulae for the q limits reduce to 0 and 2k for elastic.</p>
<p><span class="math notranslate nohighlight">\(q_i^{min} = |k_{i+1} - k_i|\)</span></p>
<p><span class="math notranslate nohighlight">\(q_i^{max} = q_i^{min} + 2 min(k_i, k_{i+1})\)</span></p>
<p>The following substitutions are then performed in order to make it more convenient to evaluate as a Monte Carlo integral:</p>
<p><span class="math notranslate nohighlight">\(t_i = \frac{1-e^{-\mu_T l_i}}{1-e^{-\mu_T l_i^{max}}}\)</span></p>
<p><span class="math notranslate nohighlight">\(u_i = \frac{\phi_i}{2 \pi}\)</span></p>
<p><span class="math notranslate nohighlight">\(2 k_i^2 = \frac{\sigma_s}{\sigma_s(k_i)} I(k_i)\)</span> where <span class="math notranslate nohighlight">\(I(k) = \iint \limits_{D(k)} Q S(Q, \omega) dQ d\omega\)</span></p>
<p>Using the new variables the integral is:</p>
<div class="math notranslate nohighlight">
\[J_n = \frac{1}{A} \int\hspace{-3pt}dS\int_{0}^{1}\hspace{-3pt}dt_1 \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\int_{0}^{1}\hspace{-3pt}dt_{i+1}\int_{0}^{1} du_i \iint \limits_{D(k_i)}\hspace{-3pt}dQ_i d\omega_i\frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T} \frac{Q_i S(Q_i, \omega_i)}{I(k_i)} \sigma_s(k_i)] e^{-\mu_T l_{out}} S(Q_n, \omega_n) \frac{\sigma_s}{4 \pi}\]</div>
<p>This is evaluated as a Monte Carlo integration by selecting random values for the variables <span class="math notranslate nohighlight">\(t_i\)</span> and <span class="math notranslate nohighlight">\(u_i\)</span> between 0 and 1. The integral over <span class="math notranslate nohighlight">\(Q\omega\)</span> space is performed by integrating a slightly modified <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span> function over a rectangular region. <span class="math notranslate nohighlight">\(S_{kin}(Q,\omega)\)</span> equals zero if <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(\omega\)</span> are outside the kinematically accessible region.
The rectangular region spans the full length of the <span class="math notranslate nohighlight">\(\omega\)</span> axis in the <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span> profile and goes from zero to the maximum possible <span class="math notranslate nohighlight">\(Q_i\)</span> for a particular <span class="math notranslate nohighlight">\(k_i\)</span> in the q direction.</p>
<p>A simulated path is traced through the sample to enable the <span class="math notranslate nohighlight">\(l_i^{\ max}\)</span> values to be calculated. The path is traced by calculating the <span class="math notranslate nohighlight">\(l_i\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> values as follows from the random variables. The code keeps a note of the start coordinates of the current path segment and updates it when moving to the next segment using these randomly selected lengths and directions:</p>
<p><span class="math notranslate nohighlight">\(l_i = -\frac{1}{\mu_T}ln(1-(1-e^{-\mu_T l_i^{\ max}})t_i)\)</span></p>
<p><span class="math notranslate nohighlight">\(\cos\theta_i = (k_i^2 + k_{i+1}^2 - Q_i^2)/2 k_i k_{i+1}\)</span></p>
<p><span class="math notranslate nohighlight">\(\phi_i = 2 \pi u_i\)</span></p>
<p>The final Monte Carlo integration that is actually performed by the code is as follows where N is the number of scenarios:</p>
<div class="math notranslate nohighlight">
\[J_n = \frac{1}{N}\sum \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T} \frac{\Delta Q_i \Delta \omega Q_i S_{kin}(Q_i, \omega_i)}{I(k_i)} \sigma_s(k_i)] e^{-\mu_T l_{out}} S(Q_n, \omega_n) \frac{\sigma_s}{4 \pi}\]</div>
<p>where the integration ranges over the rectangular <span class="math notranslate nohighlight">\(Q \omega\)</span> region are defined as follows:</p>
<p><span class="math notranslate nohighlight">\(\Delta\omega = \omega^{max}-\omega^{min}\)</span></p>
<p><span class="math notranslate nohighlight">\(\Delta Q_i = k_i + \frac{2m}{\hbar}\sqrt{\frac{\hbar^2 k_i^2}{2m} - \omega_{min}}\)</span></p>
<p>This is similar to the formulation described in the Mancinelli paper except there is no random variable to decide whether a particular scattering event is coherent or incoherent.</p>
<p>The integral <span class="math notranslate nohighlight">\(I(k)\)</span> is evaluated deterministically up front at a set of k values and interpolated as required.</p>
<p>The factor for the final track segment can also be normalised by setting <code class="docutils literal notranslate"><span class="pre">NormalizeStructureFactors=true</span></code> which replaces <span class="math notranslate nohighlight">\(\sigma_s\)</span> with <span class="math notranslate nohighlight">\(2k_n^2 \sigma_s(k_n)/I(k_n)\)</span>. This feature wasn’t in the original Discus implementation.</p>
<p>The results for different <span class="math notranslate nohighlight">\(\omega\)</span> values can be calculated by simulating tracks separately for each <span class="math notranslate nohighlight">\(\omega\)</span> value or the same tracks can be reused with the multiple weights for the final track segment being calculated to achieve the required range of overall energy transfers.
Discus used the latter approach which results in the results for different <span class="math notranslate nohighlight">\(\omega\)</span> being correlated. This choice is controlled using the <code class="docutils literal notranslate"><span class="pre">SimulateEnergiesIndependently</span></code> parameter</p>
<section id="importance-sampling">
<h4><a class="toc-backref" href="#id13" role="doc-backlink">Importance Sampling</a><a class="headerlink" href="#importance-sampling" title="Permalink to this heading">¶</a></h4>
<p>The algorithm includes an option to use importance sampling to improve the results for elastic instrument when running with S(Q) profiles containing spikes.
Without this option enabled, the contribution from rare, high values in the structure factor is only visible at a very high number of scenarios.</p>
<p>The importance sampling is achieved using a further change of variables as follows:</p>
<p><span class="math notranslate nohighlight">\(v_i = P(Q_i) = \frac{I(Q_i)}{I(2k)}\)</span> where <span class="math notranslate nohighlight">\(I(x) = \int_{0}^{x} Q S(Q) dQ\)</span></p>
<p>With this approach the Q value for each segment is chosen as follows based on a <span class="math notranslate nohighlight">\(v_i\)</span> value randomly selected between 0 and 1:</p>
<p><span class="math notranslate nohighlight">\(Q_i = P^{-1}(v_i)\)</span></p>
<p><span class="math notranslate nohighlight">\(\cos\theta_i\)</span> is determined from <span class="math notranslate nohighlight">\(Q_i\)</span> as before. The change of variables gives the following integral for <span class="math notranslate nohighlight">\(J_n\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}J_n = \frac{1}{A} \int dS \int_{0}^{1} dt_1 \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\int_{0}^{1} dt_{i+1} \int_{0}^{1} dv_i \frac{I(2k)}{2k^2} \sigma_s \int_{0}^{1} du_i \frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T}] e^{-\mu_T l_{out}} S(Q_n) \frac{\sigma_s}{4 \pi}\\J_n = \frac{1}{A} \int dS \int_{0}^{1} dt_1 \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\int_{0}^{1} dt_{i+1} \int_{0}^{1} dv_i \sigma_s(k) \int_{0}^{1} du_i \frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T}] e^{-\mu_T l_{out}} S(Q_n) \frac{\sigma_s}{4 \pi}\end{aligned}\end{align} \]</div>
<p>Finally, the equivalent Monte Carlo integration that the algorithm performs with importance sampling enabled is:</p>
<div class="math notranslate nohighlight">
\[J_n = \frac{1}{N}\sum \frac{1-e^{-\mu_T l_1^{\ max}}}{\sigma_T} \prod\limits_{i=1}^{n-1}[\sigma_s(k) \frac{(1-e^{-\mu_T l_{i+1}^{max}})}{\sigma_T}] e^{-\mu_T l_{out}} S(Q_n) \frac{\sigma_s}{4 \pi}\]</div>
<p>The importance sampling has also been implemented for inelastic instruments by flatting out the 2D <span class="math notranslate nohighlight">\(S(Q, \omega)\)</span> profile into a 1D array.
A 1D coordinate is created which is the actual Q value added onto the maximum Q from the preceding <span class="math notranslate nohighlight">\(\omega\)</span> row: <span class="math notranslate nohighlight">\(Q'(Q,\omega_i) = Q + Q_{max}(\omega_{i-1})\)</span>
With this approach there is no interpolation performed between different <span class="math notranslate nohighlight">\(\omega\)</span> values. It’s not clear whether the importance sampling is useful for inelastic calculations since the area where the multiple scattering correction tends to be largest relative to the signal is away from the peak in <span class="math notranslate nohighlight">\(S(Q, \omega)\)</span>.</p>
</section>
<section id="support-for-sample-environment">
<h4><a class="toc-backref" href="#id14" role="doc-backlink">Support for sample environment</a><a class="headerlink" href="#support-for-sample-environment" title="Permalink to this heading">¶</a></h4>
<p>The calculation can include scattering from the sample environment (e.g. can) in the Monte Carlo simulation. The term “segment” has previously been used to refer to a straight neutron path between two scattering events. For the purpose of this description the term “link” will be used to refer to a subsection of a segment that lies within a single material.</p>
<p>The modified calculation is illustrated here with an example of a sample contained in a can where a track may contain three different links (can, then sample, then can). If the selected scatter point occurs somewhere in the third link, the quantity <span class="math notranslate nohighlight">\(t_i\)</span> is redefined as:</p>
<div class="math notranslate nohighlight">
\[t_i = \frac{1-e^{-\mu_1 l_1^{max} - \mu_2 l_2^{max} - \mu_3 (l_i - l_1^{max} - l_2^{max})}}{1-e^{-\mu_1 l_1^{max} - \mu_2 l_2^{max} - \mu_3 l_3^{max}}}\]</div>
<p>This can be generally expressed as follows where n is the number of sample environment components:</p>
<div class="math notranslate nohighlight">
\[t_i = \frac{1-e^{-\sum\limits_{j=1}^{n} \mu_j\ min(max( l_i - \sum\limits_{k=1}^{j-1} l_k^{max},\ 0),\ l_j^{max})}}{1-e^{-\sum\limits_{j=1}^{n} \mu_j l_j^{max}}}\]</div>
<p>Based on this the length of the ith segment can be derived from a <span class="math notranslate nohighlight">\(t_i\)</span> that has been randomly selected between 0 and 1 as follows where again the expression is for the specific case of a track containing three different links:</p>
<div class="math notranslate nohighlight" id="equation-l-i">
<span class="eqno">(1)<a class="headerlink" href="#equation-l-i" title="Permalink to this equation">¶</a></span>\[\mu_1 l_1^{max} + \mu_2 l_2^{max} + \mu_3 (l_i - l_1^{max} - l_2^{max}) = - ln(1-(1-e^{-\sum\limits_{j=1}^{n}\mu_j l_j^{max}})t_i)\]</div>
<p>…and more generally (although perhaps less helpfully in terms of explaining how the code works):</p>
<div class="math notranslate nohighlight">
\[\sum\limits_{j=1}^{n} \mu_j\ min(max( l_i - \sum\limits_{k=1}^{j-1} l_k^{max},\ 0),\ l_j^{max}) = - ln(1-(1-e^{-\sum\limits_{j=1}^{n}\mu_j l_j^{max}})t_i)\]</div>
<p>It can be seen that the formula <a class="reference internal" href="#equation-l-i">(1)</a> can be solved for <span class="math notranslate nohighlight">\(l_i\)</span> by calculating the quantity on the right hand side and then sequentially subtracting <span class="math notranslate nohighlight">\(\mu_i l_i^{max}\)</span> from it for increasing i while keeping the running total &gt;=0.
The value of <span class="math notranslate nohighlight">\(i\)</span> when you can’t subtract any more <span class="math notranslate nohighlight">\(\mu_i l_i^{max}\)</span> identifies the component containing the scatter. Dividing by <span class="math notranslate nohighlight">\(\mu_i\)</span> at this point gives you the length into that component that the track reaches.</p>
<p>The other modification to the calculation to support scattering in the sample environment is that a different structure factor <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span> , <span class="math notranslate nohighlight">\(I(k)\)</span> and scattering cross section <span class="math notranslate nohighlight">\(\sigma_s\)</span> is required for each material. The component containing each scatter is derived from the <span class="math notranslate nohighlight">\(l_i\)</span> calculation and is used to look up the material.</p>
</section>
</section>
<section id="outputs">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Outputs</a><a class="headerlink" href="#outputs" title="Permalink to this heading">¶</a></h3>
<p>The algorithm outputs a workspace group containing the following workspaces:</p>
<ul class="simple">
<li><p>Several workspaces called <code class="docutils literal notranslate"><span class="pre">Scatter_n</span></code> where n is the number of scattering events considered. Each workspace contains “per detector” weights as a function of momentum or energy transfer for a specific number of scattering events. The number of scattering events ranges between 1 and the number specified in the NumberOfScatterings parameter</p></li>
<li><p>Several workspaces called <code class="docutils literal notranslate"><span class="pre">Scatter_n_Integrated</span></code> which are integrals of the <code class="docutils literal notranslate"><span class="pre">Scatter_n</span></code> workspaces across the x axis (Momentum for elastic and DeltaE for inelastic)</p></li>
<li><p>A workspace called <code class="docutils literal notranslate"><span class="pre">Scatter_1_NoAbsorb</span></code> is also created for a scenario where neutrons are scattered once, absorption is assumed to be zero and re-scattering after the simulated scattering event is assumed to be zero. This is the quantity <span class="math notranslate nohighlight">\(J_{1}^{*}\)</span> described in the Discus manual</p></li>
<li><p>A workspace called <code class="docutils literal notranslate"><span class="pre">Scatter_2_n_Summed</span></code> which is the sum of the <code class="docutils literal notranslate"><span class="pre">Scatter_n</span></code> workspaces for n &gt; 1</p></li>
<li><p>A workspace called <code class="docutils literal notranslate"><span class="pre">Scatter_1_n_Summed</span></code> which is the sum of the <code class="docutils literal notranslate"><span class="pre">Scatter_n</span></code> workspaces for n &gt;= 1</p></li>
<li><p>A workspace called <code class="docutils literal notranslate"><span class="pre">Ratio_Single_To_All</span></code> which is the <code class="docutils literal notranslate"><span class="pre">Scatter_1</span></code> workspace divided by <code class="docutils literal notranslate"><span class="pre">Scatter_1_n_Summed</span></code></p></li>
</ul>
<p>The output can be applied to a workspace containing a real sample measurement in one of two ways:</p>
<ul class="simple">
<li><p>subtraction method. The additional intensity contributed by multiple scattering to either a raw measurement or a vanadium corrected measurement can be calculated from the weights output from this algorithm. The additional intensity can then be subtracted to give an idealised “single scatter” intensity.
For example, the additional intensity measured at a detector due to multiple scattering is given by <span class="math notranslate nohighlight">\((\sum_{n=2}^{\infty} J_n) E(\lambda) I_0(\lambda) \Delta \Omega\)</span> where <span class="math notranslate nohighlight">\(E(\lambda)\)</span> is the detector efficiency, <span class="math notranslate nohighlight">\(I_0(\lambda)\)</span> is the incident intensity and <span class="math notranslate nohighlight">\(\Delta \Omega\)</span> is the solid angle subtended by the detector.
The factors <span class="math notranslate nohighlight">\(E(\lambda) I_0(\lambda) \Delta \Omega\)</span> can be obtained from a Vanadium run - although to take advantage of the “per detector” multiple scattering weights, the preparation of the Vanadium data will need to take place “per detector” instead of on focussed datasets</p></li>
<li><p>factor method. The correction can be applied by multiplying the real sample measurement by <span class="math notranslate nohighlight">\(J_1/\sum_{n=1}^{\infty} J_n\)</span>. This approach avoids having to create a suitably normalised intensity from the weights and the method is also more tolerant of any normalisation inaccuracies in the S(Q) profile</p></li>
</ul>
<p>The multiple scattering correction should be applied before applying an absorption correction.</p>
<p>The Discus manual describes a further method of applying an attenuation correction and a multiple scattering correction in one step using a variation of the factor method. To achieve this the real sample measurement should be multipled by <span class="math notranslate nohighlight">\(J_1^{*}/(\sum_{n=1}^{\infty} J_n\)</span>).
Note that this differs from the approach taken in other Mantid absorption correction algorithms such as MonteCarloAbsorption because of the properties of <span class="math notranslate nohighlight">\(J_{1}^{*}\)</span>.
<span class="math notranslate nohighlight">\(J_{1}^{*}\)</span> corrects for attenuation due to absorption before and after the simulated scattering event (which is the same as MonteCarloAbsorption) but it only corrects for attenuation due to scattering after the simulated scattering event.
For this reason it’s not clear this feature from Discus is useful but it has been left in for historical reasons.</p>
<p>The sample shape (and optionally the sample environment shape) can be specified by running the algorithms <a class="reference internal" href="SetSample-v1.html#algm-setsample"><span class="std std-ref">SetSample</span></a> or <a class="reference internal" href="LoadSampleShape-v1.html#algm-loadsampleshape"><span class="std std-ref">LoadSampleShape</span></a> on the input workspace prior to running this algorithm.</p>
<p>The algorithm can take a long time to run on instruments with a lot of spectra andor a lot of bins in each spectrum. The run time can be reduced by enabling the following interpolation features:</p>
<ul class="simple">
<li><p>the multiple scattering correction can be calculated on a subset of the bins in the input workspace by specifying a non-default value for NumberOfSimulationPoints. The other points will be calculated by interpolation</p></li>
<li><p>the algorithm can be performed on a subset of the detectors by setting SparseInstrument=True</p></li>
</ul>
<p>Both of these interpolation features are described further in the documentation for the <a class="reference internal" href="MonteCarloAbsorption-v1.html#algm-montecarloabsorption"><span class="std std-ref">MonteCarloAbsorption</span></a> algorithm</p>
</section>
</section>
<section id="usage">
<h2><a class="toc-backref" href="#id16" role="doc-backlink">Usage</a><a class="headerlink" href="#usage" title="Permalink to this heading">¶</a></h2>
<p><strong>Example - elastic calculation on single spike S(Q) and an isotropic S(Q) for comparison</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span> <span class="nn">mantid</span> <span class="kn">import</span> <span class="n">mtd</span>
<span class="kn">from</span> <span class="nn">mantid.simpleapi</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># S(Q) consisting of single spike at q=1</span>
<span class="c1"># Spike height gives same normalisation as isotropic (integral of Q.S(Q) the same)</span>
<span class="n">X</span><span class="o">=</span><span class="p">[</span><span class="mf">0.99</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.01</span><span class="p">]</span>
<span class="n">Y</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mf">0.</span><span class="p">]</span>
<span class="n">Sofq</span><span class="o">=</span><span class="n">CreateWorkspace</span><span class="p">(</span><span class="n">DataX</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">DataY</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span><span class="n">UnitX</span><span class="o">=</span><span class="s2">&quot;MomentumTransfer&quot;</span><span class="p">)</span>

<span class="c1"># Isotropic S(Q)</span>
<span class="n">X</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
<span class="n">Y</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
<span class="n">Sofq_isotropic</span><span class="o">=</span><span class="n">CreateWorkspace</span><span class="p">(</span><span class="n">DataX</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">DataY</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span><span class="n">UnitX</span><span class="o">=</span><span class="s2">&quot;MomentumTransfer&quot;</span><span class="p">)</span>

<span class="n">two_thetas</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">180</span><span class="p">):</span>
    <span class="n">two_thetas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="c1"># workspace with single bin centred at k=1 Angstrom-1</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">CreateSampleWorkspace</span><span class="p">(</span><span class="n">WorkspaceType</span><span class="o">=</span><span class="s2">&quot;Histogram&quot;</span><span class="p">,</span>
                           <span class="n">XUnit</span><span class="o">=</span><span class="s2">&quot;Momentum&quot;</span><span class="p">,</span>
                           <span class="n">Xmin</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                           <span class="n">Xmax</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
                           <span class="n">BinWidth</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                           <span class="n">NumBanks</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">)</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span>
                           <span class="n">BankPixelWidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">InstrumentName</span><span class="o">=</span><span class="s2">&quot;testinst&quot;</span><span class="p">)</span>

<span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">EditInstrumentGeometry</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span>
    <span class="n">PrimaryFlightPath</span><span class="o">=</span><span class="mf">14.0</span><span class="p">,</span>
    <span class="n">SpectrumIDs</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
    <span class="n">L2</span><span class="o">=</span><span class="p">[</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
    <span class="n">Polar</span><span class="o">=</span><span class="n">two_thetas</span><span class="p">,</span>
    <span class="n">Azimuthal</span><span class="o">=</span><span class="p">[</span><span class="mf">90.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
    <span class="n">DetectorIDs</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
    <span class="n">InstrumentName</span><span class="o">=</span><span class="s2">&quot;testinst&quot;</span><span class="p">)</span>

<span class="n">sphere_xml</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\</span>
<span class="s2">&lt;sphere id=&#39;some-sphere&#39;&gt; </span><span class="se">\</span>
<span class="s2">    &lt;centre x=&#39;0.0&#39;  y=&#39;0.0&#39; z=&#39;0.0&#39; /&gt; </span><span class="se">\</span>
<span class="s2">    &lt;radius val=&#39;0.01&#39; /&gt; </span><span class="se">\</span>
<span class="s2">&lt;/sphere&gt; </span><span class="se">\</span>
<span class="s2">&lt;algebra val=&#39;some-sphere&#39; /&gt; </span><span class="se">\</span>
<span class="s2">&quot;</span>
<span class="n">SetSample</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span>
          <span class="n">Geometry</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Shape&#39;</span><span class="p">:</span> <span class="s1">&#39;CSG&#39;</span><span class="p">,</span> <span class="s1">&#39;Value&#39;</span><span class="p">:</span> <span class="n">sphere_xml</span><span class="p">},</span>
          <span class="n">Material</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;NumberDensity&#39;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span> <span class="s1">&#39;AttenuationXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                    <span class="s1">&#39;CoherentXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;IncoherentXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;ScatteringXSection&#39;</span><span class="p">:</span> <span class="mf">80.0</span><span class="p">})</span>

<span class="n">results_group</span> <span class="o">=</span> <span class="n">DiscusMultipleScatteringCorrection</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span> <span class="n">StructureFactorWorkspace</span><span class="o">=</span><span class="n">Sofq</span><span class="p">,</span>
                                                   <span class="n">OutputWorkspace</span><span class="o">=</span><span class="s2">&quot;MuscatResults&quot;</span><span class="p">,</span> <span class="n">NeutronPathsSingle</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                                   <span class="n">NeutronPathsMultiple</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">ImportanceSampling</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Can&#39;t index into workspace group by name (yet) so just get the members from the ADS instead</span>
<span class="n">Scatter_1_DeltaFunction</span> <span class="o">=</span> <span class="n">CloneWorkspace</span><span class="p">(</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">)</span>
<span class="n">Scatter_2_DeltaFunction</span> <span class="o">=</span> <span class="n">CloneWorkspace</span><span class="p">(</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">)</span>
<span class="n">DeleteWorkspace</span><span class="p">(</span><span class="s1">&#39;MuscatResults&#39;</span><span class="p">)</span>

<span class="n">DiscusMultipleScatteringCorrection</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span> <span class="n">StructureFactorWorkspace</span><span class="o">=</span><span class="n">Sofq_isotropic</span><span class="p">,</span>
                                   <span class="n">OutputWorkspace</span><span class="o">=</span><span class="s2">&quot;MuscatResultsIsotropic&quot;</span><span class="p">,</span> <span class="n">NeutronPathsSingle</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
                                   <span class="n">NeutronPathsMultiple</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">ImportanceSampling</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">Scatter_2_Isotropic</span> <span class="o">=</span> <span class="n">CloneWorkspace</span><span class="p">(</span><span class="s1">&#39;MuscatResultsIsotropic_Scatter_2&#39;</span><span class="p">)</span>


<span class="c1"># q=2ksin(theta), so q spike corresonds to single scatter spike at ~60 degrees, double scatter spikes at 0 and 120 degrees</span>
<span class="n">msplot</span> <span class="o">=</span> <span class="n">plotBin</span><span class="p">(</span><span class="s1">&#39;Scatter_2_DeltaFunction&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">msplot</span> <span class="o">=</span> <span class="n">plotBin</span><span class="p">(</span><span class="s1">&#39;Scatter_1_DeltaFunction&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">msplot</span><span class="p">)</span>
<span class="n">msplot</span> <span class="o">=</span> <span class="n">plotBin</span><span class="p">(</span><span class="s1">&#39;Scatter_2_Isotropic&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">msplot</span><span class="p">)</span>
<span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Spectrum (~scattering angle in degrees)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.6</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Single and Double Scatter Intensities&quot;</span><span class="p">)</span>
<span class="n">mtd</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-1.py">Source code</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-1.png">png</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-1.hires.png">hires.png</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-1.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="../_images/DiscusMultipleScatteringCorrection-v1-1.png" class="plot-directive" src="../_images/DiscusMultipleScatteringCorrection-v1-1.png" />
</figure>
<p>The double scatter profile shows a similar shape to the analytic result calculated in <a class="footnote-reference brackets" href="#may" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>:</p>
<figure class="align-default">
<img alt="../_images/MayersMultipleScatteringFigure9.png" src="../_images/MayersMultipleScatteringFigure9.png" />
</figure>
<p><strong>Example - inelastic calculation on direct geometry (matches calculation in DISCUS paper</strong> <a class="footnote-reference brackets" href="#joh" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> <strong>figure 1)</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span> <span class="nn">mantid.simpleapi</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c1"># parameterised Lorentzian S(Q,w) from Discus pdf</span>
<span class="c1"># wavelength = 4 Angstroms, k=1.57</span>
<span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">SpecAxis</span> <span class="o">=</span><span class="p">[],[],[]</span>
<span class="n">qmin</span><span class="p">,</span> <span class="n">qmax</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span><span class="mf">4.0</span>
<span class="n">nqpts</span> <span class="o">=</span> <span class="mi">9</span>
<span class="n">wmin</span><span class="p">,</span> <span class="n">wmax</span> <span class="o">=</span> <span class="o">-</span><span class="mf">5.85</span><span class="p">,</span> <span class="mf">5.85</span> <span class="c1"># meV</span>
<span class="n">nwpts</span> <span class="o">=</span> <span class="mi">79</span> <span class="c1"># negative w is given explicitly so ~double number of pts in Discus</span>
<span class="n">D</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="c1"># Angstom-2 meV -1 = 2.3E-05 cm2 s-1</span>
<span class="n">TEMP</span><span class="o">=</span><span class="mi">300</span>
<span class="n">HOVERT</span> <span class="o">=</span> <span class="mf">11.6087</span><span class="o">/</span><span class="n">TEMP</span>
<span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqpts</span><span class="p">):</span>
   <span class="n">q</span> <span class="o">=</span> <span class="n">iq</span> <span class="o">*</span> <span class="p">(</span><span class="n">qmax</span><span class="o">-</span><span class="n">qmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nqpts</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">qmin</span>
   <span class="n">SpecAxis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nwpts</span><span class="p">):</span>
     <span class="n">w</span> <span class="o">=</span> <span class="n">iw</span> <span class="o">*</span> <span class="p">(</span><span class="n">wmax</span><span class="o">-</span><span class="n">wmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nwpts</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">wmin</span>
     <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">==</span><span class="mf">0.</span><span class="p">):</span>
        <span class="c1"># Discus S(Q,w) has zero here so do likewise</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Denominator zero so outputting S(q,w)=0&quot;</span><span class="p">)</span>
        <span class="n">Y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
     <span class="k">else</span><span class="p">:</span>
        <span class="n">Sqw</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># Apply detailed balance, neutrons more likely to lose energy in each scatter</span>
        <span class="c1"># Mantid has w = Ei-Ef</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">):</span>
           <span class="n">Sqw</span> <span class="o">=</span> <span class="n">Sqw</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">HOVERT</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
        <span class="c1"># S(Q,w) is capped at exactly 4.0 for some reason in Discus example</span>
        <span class="n">Y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Sqw</span><span class="p">,</span><span class="mf">4.0</span><span class="p">))</span>

<span class="n">sqw</span> <span class="o">=</span> <span class="n">CreateWorkspace</span><span class="p">(</span><span class="n">DataX</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">DataY</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span><span class="n">UnitX</span><span class="o">=</span><span class="s2">&quot;DeltaE&quot;</span><span class="p">,</span>
                      <span class="n">VerticalAxisUnit</span><span class="o">=</span><span class="s2">&quot;MomentumTransfer&quot;</span><span class="p">,</span>
                      <span class="n">VerticalAxisValues</span><span class="o">=</span><span class="n">SpecAxis</span><span class="p">,</span> <span class="n">NSpec</span><span class="o">=</span><span class="n">nqpts</span><span class="p">)</span>

<span class="n">two_thetas</span> <span class="o">=</span> <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">,</span> <span class="mf">90.0</span><span class="p">]</span>

<span class="n">ws</span> <span class="o">=</span> <span class="n">CreateSampleWorkspace</span><span class="p">(</span><span class="n">WorkspaceType</span><span class="o">=</span><span class="s2">&quot;Histogram&quot;</span><span class="p">,</span>
                           <span class="n">XUnit</span><span class="o">=</span><span class="s2">&quot;DeltaE&quot;</span><span class="p">,</span>
                           <span class="n">Xmin</span><span class="o">=</span><span class="n">wmin</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">wmax</span><span class="o">-</span><span class="n">wmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nwpts</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                           <span class="n">Xmax</span><span class="o">=</span><span class="n">wmax</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">wmax</span><span class="o">-</span><span class="n">wmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nwpts</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                           <span class="n">BinWidth</span><span class="o">=</span><span class="p">(</span><span class="n">wmax</span><span class="o">-</span><span class="n">wmin</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nwpts</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                           <span class="n">NumBanks</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
                           <span class="n">BankPixelWidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">InstrumentName</span><span class="o">=</span><span class="s2">&quot;testinst&quot;</span><span class="p">)</span>

<span class="c1"># set up ring of detectors in yz plane</span>
<span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">EditInstrumentGeometry</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span>
    <span class="n">PrimaryFlightPath</span><span class="o">=</span><span class="mf">14.0</span><span class="p">,</span>
    <span class="n">SpectrumIDs</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
    <span class="n">L2</span><span class="o">=</span><span class="p">[</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
    <span class="n">Polar</span><span class="o">=</span><span class="n">two_thetas</span><span class="p">,</span>
    <span class="c1">#azimuthal angle=phi, phi=0 along x axis and increases as move towards vertical y axis</span>
    <span class="n">Azimuthal</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">90.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">),</span>
    <span class="n">DetectorIDs</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span>
    <span class="n">InstrumentName</span><span class="o">=</span><span class="s2">&quot;testinst&quot;</span><span class="p">)</span>

<span class="c1"># flat plate sample 5cm x 5cm x 0.065cm</span>
<span class="n">cuboid_xml</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\</span>
<span class="s2">&lt;cuboid id=&#39;flatplate&#39;&gt; </span><span class="se">\</span>
<span class="s2">  &lt;width val=&#39;0.05&#39; /&gt; </span><span class="se">\</span>
<span class="s2">  &lt;height val=&#39;0.05&#39;  /&gt; </span><span class="se">\</span>
<span class="s2">  &lt;depth  val=&#39;0.00065&#39; /&gt; </span><span class="se">\</span>
<span class="s2">  &lt;centre x=&#39;0.0&#39; y=&#39;0.0&#39; z=&#39;0.0&#39;  /&gt; </span><span class="se">\</span>
<span class="s2">  &lt;rotate x=&#39;45&#39; y=&#39;0&#39; z=&#39;0&#39; /&gt; </span><span class="se">\</span>
<span class="s2">&lt;/cuboid&gt; </span><span class="se">\</span>
<span class="s2">&quot;</span>
<span class="n">SetSample</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span>
          <span class="n">Geometry</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;Shape&#39;</span><span class="p">:</span> <span class="s1">&#39;CSG&#39;</span><span class="p">,</span> <span class="s1">&#39;Value&#39;</span><span class="p">:</span> <span class="n">cuboid_xml</span><span class="p">},</span>
          <span class="n">Material</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;NumberDensity&#39;</span><span class="p">:</span> <span class="mf">0.02</span><span class="p">,</span> <span class="s1">&#39;AttenuationXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
                    <span class="s1">&#39;CoherentXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;IncoherentXSection&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;ScatteringXSection&#39;</span><span class="p">:</span> <span class="mf">80.0</span><span class="p">})</span>

<span class="c1">#match Ei value from DISCUS pdf Figure 1</span>
<span class="n">ws</span><span class="o">.</span><span class="n">run</span><span class="p">()</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s2">&quot;deltaE-mode&quot;</span><span class="p">,</span> <span class="s2">&quot;Direct&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">);</span>
<span class="n">ws</span><span class="o">.</span><span class="n">run</span><span class="p">()</span><span class="o">.</span><span class="n">addProperty</span><span class="p">(</span><span class="s2">&quot;Ei&quot;</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">,</span> <span class="kc">True</span><span class="p">);</span>

<span class="n">DiscusMultipleScatteringCorrection</span><span class="p">(</span><span class="n">InputWorkspace</span><span class="o">=</span><span class="n">ws</span><span class="p">,</span> <span class="n">StructureFactorWorkspace</span><span class="o">=</span><span class="n">sqw</span><span class="p">,</span>
                                   <span class="n">OutputWorkspace</span><span class="o">=</span><span class="s2">&quot;MuscatResults&quot;</span><span class="p">,</span> <span class="n">NeutronPathsSingle</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                                   <span class="n">NeutronPathsMultiple</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># reverse w axis because Discus w = Ef-Ei (opposite to Mantid)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dataY</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dataE</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">setY</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">setE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getNumberHistograms</span><span class="p">()):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dataY</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dataE</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">setY</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">setE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;figure.figsize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;projection&#39;</span><span class="p">:</span><span class="s1">&#39;mantid&#39;</span><span class="p">})</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_1&#39;</span><span class="p">],</span> <span class="n">wkspIndex</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Single: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; degrees&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">two_thetas</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mtd</span><span class="p">[</span><span class="s1">&#39;MuscatResults_Scatter_2&#39;</span><span class="p">],</span> <span class="n">wkspIndex</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Double: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; degrees&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">,</span><span class="mf">1e-1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mf">7.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Inelastic Double</span><span class="se">\\</span><span class="s2">Single Scattering Weights&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">mtd</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-2.py">Source code</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-2.png">png</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-2.hires.png">hires.png</a>, <a class="reference external" href="../algorithms/DiscusMultipleScatteringCorrection-v1-2.pdf">pdf</a>)</p>
<figure class="align-default">
<img alt="../_images/DiscusMultipleScatteringCorrection-v1-2.png" class="plot-directive" src="../_images/DiscusMultipleScatteringCorrection-v1-2.png" />
</figure>
<p>This is the equivalent plot from the original Discus Fortran program:</p>
<figure class="align-default">
<img alt="../_images/DiscusMultipleScatteringFigure1.png" src="../_images/DiscusMultipleScatteringFigure1.png" />
</figure>
</section>
<section id="references">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">References</a><a class="headerlink" href="#references" title="Permalink to this heading">¶</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="joh" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id6">2</a>)</span>
<p>M W Johnson, 1974 AERE Report R7682, Discus: A computer program for the calculating of multiple scattering effects in inelastic neutron scattering experiments</p>
</aside>
<aside class="footnote brackets" id="how" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>WS Howells, V Garcia Sakai, F Demmel, MTF Telling, F Fernandez-Alonso, Feb 2010, MODES manual RAL-TR-2010-006, <a class="reference external" href="https://doi.org/10.5286/raltr.2010006">doi: 10.5286/raltr.2010006</a></p>
</aside>
<aside class="footnote brackets" id="how2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/mantidproject/3rdpartysources/tree/master/Fortran/Indirect/AbsCorrection">FORTRAN source code for MUSCAT</a></p>
</aside>
<aside class="footnote brackets" id="man" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p>R Mancinelli 2012 <em>J. Phys.: Conf. Ser.</em> <strong>340</strong> 012033, Multiple neutron scattering corrections. Some general equations to do fast evaluations <a class="reference external" href="https://doi.org/10.1088/1742-6596/340/1/012033">doi: 10.1088/1742-6596/340/1/012033</a></p>
</aside>
<aside class="footnote brackets" id="may" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p>J Mayers, R Cywinski, 1985 <em>Nuclear Instruments and Methods in Physics Research</em> A241, A Monte Carlo Evaluation Of Analytical Multiple Scattering Corrections For Unpolarised Neutron Scattering And Polarisation Analysis Data <a class="reference external" href="https://doi.org/10.1016/0168-9002(85)90607-2">doi: 10.1016/0168-9002(85)90607-2</a></p>
</aside>
</aside>
<p><strong>Categories</strong>: <a class="reference external" href="categories/AlgorithmIndex.html">AlgorithmIndex</a> | <a class="reference external" href="categories/CorrectionFunctions.html">CorrectionFunctions</a></p>
</section>
<section id="source">
<h2><a class="toc-backref" href="#id18" role="doc-backlink">Source</a><a class="headerlink" href="#source" title="Permalink to this heading">¶</a></h2>
<p>C++ header: <a class="reference external" href="https://github.com/mantidproject/mantid/blob/aa570da6f199141cd8ad987bf9b9b9281a1b5e33/Framework/Algorithms/inc/MantidAlgorithms/DiscusMultipleScatteringCorrection.h">DiscusMultipleScatteringCorrection.h</a></p>
<p>C++ source: <a class="reference external" href="https://github.com/mantidproject/mantid/blob/aa570da6f199141cd8ad987bf9b9b9281a1b5e33/Framework/Algorithms/src/DiscusMultipleScatteringCorrection.cpp">DiscusMultipleScatteringCorrection.cpp</a></p>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
      <ul class="nav navbar-nav" style=" float: right;">
      
      
          
            
  <li>
    <a href="DirectILLTubeBackground-v1.html" title="Previous Chapter: DirectILLTubeBackground v1"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; DirectILLTube...</span>
    </a>
  </li>
  <li>
    <a href="Divide-v1.html" title="Next Chapter: Divide v1"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Divide v1 &raquo;</span>
    </a>
  </li>
          
       
          <li><a href="#">Back to top</a></li>
       </ul>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>